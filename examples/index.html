<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Galaxy Shader Examples - 3x3 Grid</title>
    <style>
        html,
        body {
            height: 100vh;
            margin: 0;
            background: #0b0b0f;
            color: #eaeaf0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            overflow: hidden;
        }

        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #galaxy-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            max-width: 300px;
        }

        .controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        .controls p {
            margin: 5px 0;
            font-size: 12px;
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div id="app">
        <canvas id="galaxy-canvas"></canvas>
        <div class="controls">
            <h3>Galaxy Grid View</h3>
            <p>9 different galaxies in a 3×3 arrangement</p>
            <p>Top-down view showing spiral structures</p>
            <p>Mouse to orbit • Scroll to zoom</p>
            <p>Hover to highlight • Double-click to focus</p>
            <p>Double-click empty space to reset view</p>
        </div>
    </div>

    <script type="importmap">
    			{
    				"imports": {
    					"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
    					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/",
    					"galaxy-shader": "../dist/esm/GalaxyShader.js",
    					"galaxy-geometry": "../dist/esm/GalaxyGeometry.js"
    				}
    			}
    		</script>



    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { GalaxyShader } from 'galaxy-shader';
        import { GalaxyGeometry } from 'galaxy-geometry';

        const galaxyConfigs = [
            { // Classic Mixed Stars (Default color array)
                spiralCount: 3,
                turnsPerSpiral: 1.0,
                totalStars: 20000,
                pointSize: 2.0,
                blackHoleRadius: 0.1,
                colorMode: 0, // Fixed array cycling
                colorIntensity: 1.0
            },
            { // Radial Gradient (Hot core to cool edge)
                spiralCount: 5,
                turnsPerSpiral: 1.2,
                totalStars: 35000,
                pointSize: 1.5,
                blackHoleRadius: 0.08,
                colorMode: 1, // Gradient by radius
                colorPalette: [
                    new THREE.Color(1.0, 1.0, 0.8),  // Hot white core
                    new THREE.Color(1.0, 0.8, 0.6),  // Warm yellow
                    new THREE.Color(0.8, 0.6, 1.0),  // Cool blue
                    new THREE.Color(0.4, 0.5, 0.8)   // Cold blue edge
                ],
                colorIntensity: 1.2
            },
            { // Blue Giant Palette
                spiralCount: 2,
                turnsPerSpiral: 2.5,
                totalStars: 15000,
                pointSize: 2.5,
                blackHoleRadius: 0.15,
                colorMode: 0, // Fixed array
                colorPalette: [
                    new THREE.Color(0.7, 0.8, 1.0),   // Blue
                    new THREE.Color(0.8, 0.9, 1.0),   // Light blue
                    new THREE.Color(0.9, 0.95, 1.0),  // White-blue
                    new THREE.Color(1.0, 1.0, 1.0)    // Pure white
                ],
                colorIntensity: 1.1
            },
            { // Large Black Hole Galaxy
                spiralCount: 4,
                turnsPerSpiral: 0.8,
                totalStars: 25000,
                pointSize: 2.0,
                blackHoleRadius: 0.3,
                colorMode: 1, // Radial gradient
                colorPalette: [
                    new THREE.Color(1.0, 1.0, 1.0),   // Bright white center
                    new THREE.Color(1.0, 0.9, 0.7),   // Warm white
                    new THREE.Color(0.9, 0.7, 0.5),   // Orange
                    new THREE.Color(0.7, 0.5, 0.3)    // Dark orange edge
                ],
                colorIntensity: 1.0
            },
            { // Single Color Galaxy
                spiralCount: 3,
                turnsPerSpiral: 1.0,
                totalStars: 40000,
                pointSize: 1.0,
                blackHoleRadius: 0.12,
                colorMode: 2, // Single color
                color: new THREE.Color(1.0, 0.8, 0.6), // Warm orange
                colorIntensity: 1.0
            },
            { // Dense Green Galaxy
                spiralCount: 6,
                turnsPerSpiral: 1.5,
                totalStars: 32000,
                pointSize: 1.8,
                blackHoleRadius: 0.1,
                colorMode: 2, // Single color
                color: new THREE.Color(0.6, 1.0, 0.8), // Soft green
                colorIntensity: 1.1
            },
            { // Red Giant Galaxy
                spiralCount: 2,
                turnsPerSpiral: 0.6,
                totalStars: 8000,
                pointSize: 3.0,
                blackHoleRadius: 0.2,
                colorMode: 0, // Fixed array
                colorPalette: [
                    new THREE.Color(1.0, 0.6, 0.4),   // Orange-red
                    new THREE.Color(1.0, 0.7, 0.5),   // Orange
                    new THREE.Color(1.0, 0.8, 0.6),   // Light orange
                    new THREE.Color(1.0, 0.9, 0.7)    // Pale yellow
                ],
                colorIntensity: 1.0
            },
            { // Purple-Blue Galaxy
                spiralCount: 5,
                turnsPerSpiral: 1.0,
                totalStars: 28000,
                pointSize: 2.0,
                blackHoleRadius: 0.08,
                colorMode: 0, // Fixed array
                colorPalette: [
                    new THREE.Color(0.8, 0.4, 1.0),   // Purple
                    new THREE.Color(0.6, 0.6, 1.0),   // Blue-purple
                    new THREE.Color(0.4, 0.8, 1.0),   // Light blue
                    new THREE.Color(0.8, 0.9, 1.0)    // Very light blue
                ],
                colorIntensity: 1.2
            },
            { // Nebula Colors (Radial gradient)
                spiralCount: 4,
                turnsPerSpiral: 0.8,
                totalStars: 12000,
                pointSize: 2.8,
                blackHoleRadius: 0.25,
                colorMode: 1, // Gradient by radius
                colorPalette: [
                    new THREE.Color(1.0, 0.9, 0.8),   // Warm center
                    new THREE.Color(1.0, 0.6, 0.8),   // Pink
                    new THREE.Color(0.6, 0.4, 1.0),   // Purple
                    new THREE.Color(0.2, 0.3, 0.8)    // Deep blue edge
                ],
                colorIntensity: 1.1
            }
        ];

        function createGalaxyGrid() {
            const canvas = document.getElementById('galaxy-canvas');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Three.js setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false,
                powerPreference: 'high-performance',
            });

            renderer.setSize(width, height, false);
            renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
            renderer.setClearColor(0x0b0b0f, 1.0);

            // Add post-processing
            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(width, height),
                1.2,    // strength
                0.6,    // radius
                0.85    // threshold
            );
            composer.addPass(bloomPass);

            // Add OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 2;
            controls.maxDistance = 50;

            // Position camera to view all galaxies from above
            camera.position.set(0, 12, 0);
            controls.target.set(0, 0, 0);

            // Create 3x3 grid of galaxies
            const galaxySpacing = 3; // Distance between galaxy centers (reduced from 4)
            const galaxyScale = 0.8; // Scale down each galaxy
            const galaxies = [];
            const shaderMaterials = [];
            const galaxyBounds = []; // For mouse interaction detection

            // Mouse interaction setup
            const mouse = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();
            let hoveredGalaxy = -1; // Index of currently hovered galaxy (-1 = none)
            let focusedGalaxy = -1; // Index of currently focused/zoomed galaxy (-1 = none)
            let isAnimating = false; // Prevent interactions during camera animation

            // Store original color configurations for restoration
            const originalConfigs = galaxyConfigs.map(config => ({
                colorMode: config.colorMode,
                colorPalette: config.colorPalette ? [...config.colorPalette] : undefined,
                color: config.color ? config.color.clone() : undefined,
                colorIntensity: config.colorIntensity
            }));

            // Galaxy names for labels
            const galaxyNames = [
                'Classic Mixed', 'Radial Gradient', 'Blue Giant',
                'Large Black Hole', 'Single Orange', 'Single Green',
                'Red Giant', 'Purple-Blue', 'Nebula Colors'
            ];

            for (let i = 0; i < 9; i++) {
                const config = galaxyConfigs[i];
                const row = Math.floor(i / 3);
                const col = i % 3;

                // Calculate position in 3x3 grid
                const x = (col - 1) * galaxySpacing;
                const z = (row - 1) * galaxySpacing;
                const y = 0;

                // Create galaxy group
                const galaxyGroup = new THREE.Group();
                galaxyGroup.position.set(x, y, z);
                galaxyGroup.scale.setScalar(galaxyScale);

                // Rotate galaxy to lie flat on the XZ plane (90 degrees around X axis)
                galaxyGroup.rotation.x = Math.PI / 2;

                // Create galaxy geometry and material
                const geometry = new GalaxyGeometry(config.totalStars);
                const shaderMaterial = new GalaxyShader({
                    resolution: new THREE.Vector2(width, height),
                    color: config.color,
                    pointSize: config.pointSize * 1.5, // Compensate for scaling
                    totalStars: config.totalStars,
                    time: 0,
                    blackHoleRadius: config.blackHoleRadius,
                    blackHolePosition: new THREE.Vector3(0, 0.0, 0.0),
                    spiralCount: config.spiralCount,
                    turnsPerSpiral: config.turnsPerSpiral,
                    colorMode: config.colorMode,
                    colorPalette: config.colorPalette,
                    colorIntensity: config.colorIntensity,
                    fadeNear: 5.0,
                    fadeFar: 100.0,
                });

                const points = new THREE.Points(geometry, shaderMaterial);

                // Disable frustum culling to prevent galaxies from disappearing when center goes out of view
                points.frustumCulled = false;

                galaxyGroup.add(points);

                // Add black hole visualization
                const blackHoleGeometry = new THREE.SphereGeometry(config.blackHoleRadius, 16, 16);
                const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                galaxyGroup.add(blackHole);

                // Create invisible bounding box for mouse interaction (larger than the galaxy)
                const boundingGeometry = new THREE.PlaneGeometry(2.5, 2.5); // Adjust size as needed
                const boundingMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const boundingMesh = new THREE.Mesh(boundingGeometry, boundingMaterial);
                boundingMesh.userData = { galaxyIndex: i }; // Store galaxy index for identification
                galaxyGroup.add(boundingMesh);
                galaxyBounds.push(boundingMesh);

                // Create text label
                const canvas2d = document.createElement('canvas');
                const context = canvas2d.getContext('2d');
                canvas2d.width = 512;
                canvas2d.height = 128;

                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, canvas2d.width, canvas2d.height);

                context.font = '32px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText(galaxyNames[i], canvas2d.width / 2, canvas2d.height / 2 + 10);

                const texture = new THREE.CanvasTexture(canvas2d);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const label = new THREE.Sprite(labelMaterial);
                label.position.set(1.8, 0, 0); // Position to the right of each galaxy
                label.scale.set(1.5, 0.375, 1); // Slightly smaller labels
                galaxyGroup.add(label);

                scene.add(galaxyGroup);
                galaxies.push(galaxyGroup);
                shaderMaterials.push(shaderMaterial);
            }

            // Handle window resize
            function handleResize() {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;

                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(newWidth, newHeight, false);
                composer.setSize(newWidth, newHeight);

                // Update resolution uniforms
                shaderMaterials.forEach(material => {
                    material.uniforms.u_resolution.value.set(newWidth, newHeight);
                });
            }

            window.addEventListener('resize', handleResize);

            // Camera animation functions
            function animateCameraToGalaxy(galaxyIndex) {
                if (isAnimating || galaxyIndex < 0 || galaxyIndex >= galaxies.length) return;

                isAnimating = true;
                focusedGalaxy = galaxyIndex;

                // Get galaxy position
                const galaxy = galaxies[galaxyIndex];
                const targetPosition = galaxy.position.clone();

                // Calculate camera target position (above the galaxy)
                const cameraTargetPos = new THREE.Vector3(
                    targetPosition.x,
                    targetPosition.y + 4, // 4 units above the galaxy
                    targetPosition.z
                );

                // Store initial camera and controls state
                const initialCameraPos = camera.position.clone();
                const initialControlsTarget = controls.target.clone();

                // Animation parameters
                let progress = 0;
                const duration = 1500; // 1.5 seconds
                const startTime = performance.now();

                function animateCamera() {
                    const elapsed = performance.now() - startTime;
                    progress = Math.min(elapsed / duration, 1);

                    // Smooth easing (ease-in-out)
                    const easedProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    // Interpolate camera position
                    camera.position.lerpVectors(initialCameraPos, cameraTargetPos, easedProgress);

                    // Interpolate controls target
                    controls.target.lerpVectors(initialControlsTarget, targetPosition, easedProgress);

                    if (progress < 1) {
                        // Continue animation
                        controls.update();
                        requestAnimationFrame(animateCamera);
                    } else {
                        // Ensure final positions are exact
                        camera.position.copy(cameraTargetPos);
                        controls.target.copy(targetPosition);
                        controls.update();
                        isAnimating = false;
                    }
                }

                animateCamera();
            }

            function resetCameraView() {
                if (isAnimating) return;

                isAnimating = true;
                focusedGalaxy = -1;

                // Target positions for overview
                const overviewCameraPos = new THREE.Vector3(0, 12, 0);
                const overviewTarget = new THREE.Vector3(0, 0, 0);

                // Store current state
                const initialCameraPos = camera.position.clone();
                const initialControlsTarget = controls.target.clone();

                // Animation parameters
                let progress = 0;
                const duration = 1000; // 1 second
                const startTime = performance.now();

                function animateCamera() {
                    const elapsed = performance.now() - startTime;
                    progress = Math.min(elapsed / duration, 1);

                    // Smooth easing
                    const easedProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                    // Interpolate positions
                    camera.position.lerpVectors(initialCameraPos, overviewCameraPos, easedProgress);
                    controls.target.lerpVectors(initialControlsTarget, overviewTarget, easedProgress);

                    if (progress < 1) {
                        // Continue animation
                        controls.update();
                        requestAnimationFrame(animateCamera);
                    } else {
                        // Ensure final positions are exact
                        camera.position.copy(overviewCameraPos);
                        controls.target.copy(overviewTarget);
                        controls.update();
                        isAnimating = false;
                    }
                }

                animateCamera();
            }

            // Mouse interaction functions
            function highlightGalaxy(index) {
                // Don't highlight if this galaxy is currently focused or if animating
                if (index === focusedGalaxy || isAnimating) return;

                if (index >= 0 && index < shaderMaterials.length) {
                    const material = shaderMaterials[index];
                    // Change to cyan blue highlight
                    material.uniforms.u_colorMode.value = 2; // Single color mode
                    material.uniforms.u_color.value = new THREE.Color(0x00ffff); // Cyan
                    material.uniforms.u_colorIntensity.value = 1.5; // Brighter
                }
            }

            function restoreGalaxy(index) {
                if (index >= 0 && index < shaderMaterials.length) {
                    const material = shaderMaterials[index];
                    const originalConfig = originalConfigs[index];

                    // Restore original color configuration
                    material.uniforms.u_colorMode.value = originalConfig.colorMode;
                    material.uniforms.u_colorIntensity.value = originalConfig.colorIntensity;

                    if (originalConfig.color) {
                        material.uniforms.u_color.value = originalConfig.color;
                    }

                    if (originalConfig.colorPalette) {
                        const paddedPalette = new Array(8);
                        for (let i = 0; i < 8; i++) {
                            if (i < originalConfig.colorPalette.length) {
                                paddedPalette[i] = new THREE.Vector3(
                                    originalConfig.colorPalette[i].r,
                                    originalConfig.colorPalette[i].g,
                                    originalConfig.colorPalette[i].b
                                );
                            } else {
                                paddedPalette[i] = new THREE.Vector3(1.0, 1.0, 1.0);
                            }
                        }
                        material.uniforms.u_colorPalette.value = paddedPalette;
                        material.uniforms.u_paletteSize.value = originalConfig.colorPalette.length;
                    }
                }
            }

            function onMouseMove(event) {
                // Skip during animation
                if (isAnimating) return;

                // Calculate mouse position in normalized device coordinates (-1 to +1)
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);

                // Check for intersections with galaxy bounding boxes
                const intersects = raycaster.intersectObjects(galaxyBounds);

                if (intersects.length > 0) {
                    const newHoveredIndex = intersects[0].object.userData.galaxyIndex;

                    // Don't hover if this galaxy is currently focused
                    if (newHoveredIndex === focusedGalaxy) {
                        if (hoveredGalaxy !== -1) {
                            restoreGalaxy(hoveredGalaxy);
                            hoveredGalaxy = -1;
                        }
                        canvas.style.cursor = 'pointer';
                        return;
                    }

                    if (newHoveredIndex !== hoveredGalaxy) {
                        // Restore previous galaxy if any
                        if (hoveredGalaxy !== -1) {
                            restoreGalaxy(hoveredGalaxy);
                        }

                        // Highlight new galaxy
                        hoveredGalaxy = newHoveredIndex;
                        highlightGalaxy(hoveredGalaxy);

                        // Change cursor to pointer
                        canvas.style.cursor = 'pointer';
                    }
                } else {
                    // No galaxy hovered
                    if (hoveredGalaxy !== -1) {
                        restoreGalaxy(hoveredGalaxy);
                        hoveredGalaxy = -1;
                        canvas.style.cursor = 'default';
                    }
                }
            }

            function onDoubleClick(event) {
                // Skip during animation
                if (isAnimating) return;

                // Calculate mouse position
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);

                // Check for intersections
                const intersects = raycaster.intersectObjects(galaxyBounds);

                if (intersects.length > 0) {
                    const clickedIndex = intersects[0].object.userData.galaxyIndex;

                    if (clickedIndex === focusedGalaxy) {
                        // Double-click on focused galaxy - reset to overview
                        resetCameraView();
                    } else {
                        // Focus on this galaxy
                        // Restore previously hovered galaxy first
                        if (hoveredGalaxy !== -1) {
                            restoreGalaxy(hoveredGalaxy);
                            hoveredGalaxy = -1;
                        }
                        animateCameraToGalaxy(clickedIndex);
                    }
                } else {
                    // Double-click on empty space - reset to overview
                    if (focusedGalaxy !== -1) {
                        resetCameraView();
                    }
                }
            }

            // Add mouse event listeners
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('dblclick', onDoubleClick);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                const time = performance.now() / 10000 / 5;

                // Update time for all galaxies
                shaderMaterials.forEach((material, index) => {
                    const timeScale = galaxyConfigs[index].timeScale || 1.0;
                    material.uniforms.u_time.value = time * timeScale;
                });

                controls.update();
                composer.render();
            }

            animate();
        }

        // Initialize when page loads
        setTimeout(() => {
            createGalaxyGrid();
        }, 1000);
    </script>
</body>

</html>