<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3GSC - Three.js Points with ShaderMaterial</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0b0f;
            color: #eaeaf0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            position: fixed;
            inset: 0;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #label {
            position: absolute;
            top: 16px;
            left: 16px;
            letter-spacing: 0.08em;
            font-weight: 700;
            font-size: 18px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(20, 20, 28, 0.6);
            backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            user-select: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            bottom: 12px;
            left: 16px;
            font-size: 12px;
            opacity: 0.75;
            z-index: 10;
        }

        a {
            color: #9ab4ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="label">3GSC</div>
        <canvas id="canvas"></canvas>
        <div id="hud"></div>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        function a() {
            const canvas = document.getElementById('canvas');
            const hud = document.getElementById('hud');

            // Tweak this to increase/decrease points. Keep reasonable for laptops.
            const NUM_POINTS = 60000;

            // Check if Three.js loaded
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<p style="padding:16px">Three.js failed to load from CDN.</p>';
                return;
            }

            // Three.js setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                alpha: false,
                powerPreference: 'high-performance'
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
            renderer.setClearColor(0x0b0b0f, 1.0);

            // Position camera
            camera.position.z = 2;

            // Compute grid dimensions for points
            const gridCols = Math.ceil(Math.sqrt(NUM_POINTS));
            const gridRows = Math.ceil(NUM_POINTS / gridCols);

            // Create geometry with only point indices
            const geometry = new THREE.BufferGeometry();
            const indices = new Float32Array(NUM_POINTS); // Only need the index
            const dummyPositions = new Float32Array(NUM_POINTS * 3); // Dummy positions (will be overridden in shader)

            for (let i = 0; i < NUM_POINTS; i++) {
                indices[i] = i;
                // Set dummy positions (these will be ignored in the vertex shader)
                dummyPositions[i * 3] = 0;
                dummyPositions[i * 3 + 1] = 0;
                dummyPositions[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(dummyPositions, 3));
            geometry.setAttribute('a_index', new THREE.BufferAttribute(indices, 1));

            // Custom ShaderMaterial for points
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_color: { value: new THREE.Color(0.92, 0.94, 1.0) },
                    u_pointSize: { value: 2.0 },
                    u_gridCols: { value: gridCols },
                    u_gridRows: { value: gridRows },
                    u_totalPoints: { value: NUM_POINTS }
                },
                vertexShader: `
                    uniform vec2 u_resolution;
                    uniform float u_pointSize;
                    uniform float u_gridCols;
                    uniform float u_gridRows;
                    uniform float u_totalPoints;
                    attribute float a_index;

                    vec2 getSpiralCoordinate(float originalIndex) {
                        float totalSpirals = 1.0;
                        float totalTurns = 1.0;
                        float pointsPerSpiral = floor(u_totalPoints / totalSpirals);
                        float spiralIndex = floor(originalIndex / pointsPerSpiral);
                        float angleOffset = float(spiralIndex) / totalSpirals * 3.14159 * 2.0;
                        float index = mod(originalIndex, pointsPerSpiral);
                        // Range from 0 to 1 for the spiral
                        float radiusInSpiral = index / pointsPerSpiral;
                        float angleInSpiral = radiusInSpiral * 3.14159 * 2.0 * totalTurns + angleOffset;

                        // Convert polar to Cartesian coordinates
                        float x = cos(angleInSpiral) * radiusInSpiral;
                        float y = sin(angleInSpiral) * radiusInSpiral;
                        return vec2(x, y);

                    }

                    void main() {
                        // Calculate grid position from index
                        float col = mod(a_index, u_gridCols);
                        float row = floor(a_index / u_gridCols);
                        
                        // Map grid to [-1, 1] range
                        vec2 spiralCoord = getSpiralCoordinate(a_index);
                        
                        // Create position vector
                        vec3 pos = vec3(spiralCoord.x, spiralCoord.y, 0.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        
                        // Scale point size with screen height for consistent density
                        gl_PointSize = u_pointSize * (u_resolution.y / 900.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;

                    void main() {
                        // Round points with soft edge
                        vec2 p = gl_PointCoord * 2.0 - 1.0;
                        float d = dot(p, p);
                        if (d > 1.0) { discard; }
                        float alpha = smoothstep(1.0, 0.7, 1.0 - d);
                        gl_FragColor = vec4(u_color, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // Create Points object and add to scene
            const points = new THREE.Points(geometry, shaderMaterial);
            scene.add(points);

            // Handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

                // Update resolution uniform
                shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            }

            window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Update HUD
                hud.textContent = `Points: ${NUM_POINTS.toLocaleString()}  |  ` +
                    `Canvas: ${renderer.domElement.width}×${renderer.domElement.height}  |  ` +
                    `Grid: ${gridCols}×${gridRows}  |  Three.js`;

                // Render the scene
                renderer.render(scene, camera);
            }

            animate();
        }
        setTimeout(() => {
            a();
        }, 3000); // Show error after 5 seconds if Three.js is not loaded
    </script>
</body>

</html>