<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3GSC - Three.js Points with ShaderMaterial</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #333;
            color: #eaeaf0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            width: 600px;
            height: 600px;
            display: block;
            border-radius: 4px;
        }


        a {
            color: #9ab4ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="app">
        <canvas width="600" height="600" id="canvas"></canvas>
    </div>

    <script type="importmap">
    			{
    				"imports": {
    					"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
    					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
    				}
    			}
    		</script>



    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 600;
        function a() {
            const canvas = document.getElementById('canvas');

            // Tweak this to increase/decrease points. Keep reasonable for laptops.
            const NUM_POINTS = 20000;


            // Three.js setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                alpha: false,
                powerPreference: 'high-performance',
            });

            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
            renderer.setClearColor(0x0b0b0f, 1.0);

            // Position camera
            camera.position.z = 2;

            // Add OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movements
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5;
            controls.maxDistance = 10;

            // Compute grid dimensions for points
            const gridCols = Math.ceil(Math.sqrt(NUM_POINTS));
            const gridRows = Math.ceil(NUM_POINTS / gridCols);

            // Create geometry with only point indices
            const geometry = new THREE.BufferGeometry();
            const indices = new Float32Array(NUM_POINTS); // Only need the index
            const dummyPositions = new Float32Array(NUM_POINTS * 3); // Dummy positions (will be overridden in shader)

            for (let i = 0; i < NUM_POINTS; i++) {
                indices[i] = i;
                // Set dummy positions (these will be ignored in the vertex shader)
                dummyPositions[i * 3] = 0;
                dummyPositions[i * 3 + 1] = 0;
                dummyPositions[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(dummyPositions, 3));
            geometry.setAttribute('a_index', new THREE.BufferAttribute(indices, 1));

            // Custom ShaderMaterial for points
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_color: { value: new THREE.Color(0.92, 0.94, 1.0) },
                    u_pointSize: { value: 2.0 },
                    u_gridCols: { value: gridCols },
                    u_gridRows: { value: gridRows },
                    u_totalPoints: { value: NUM_POINTS }
                },
                vertexShader: `
                    uniform vec2 u_resolution;
                    uniform float u_pointSize;
                    uniform float u_gridCols;
                    uniform float u_gridRows;
                    uniform float u_totalPoints;
                    attribute float a_index;

                    float rand(vec2 co){
                        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
                    }

                    vec2 getSpiralCoordinate(float originalIndex) {
                        float totalSpirals = 5.0;
                        float totalTurns = 3.0;
                        float pointsPerSpiral = floor(u_totalPoints / totalSpirals);
                        float spiralIndex = floor(originalIndex / pointsPerSpiral);
                        float angleOffset = float(spiralIndex) / totalSpirals * 3.14159 * 2.0;
                        float index = mod(originalIndex, pointsPerSpiral);
                        // Range from 0 to 1 for the spiral
                        float radiusInSpiral = index / pointsPerSpiral;
                        float angleInSpiral = index / pointsPerSpiral * 3.14159 * 2.0 * totalTurns + angleOffset;

                        // Convert polar to Cartesian coordinates
                        float x = cos(angleInSpiral) * radiusInSpiral;
                        float y = sin(angleInSpiral) * radiusInSpiral;
                        return vec2(x, y);
                    }

                    vec3 getNoise(float index, float scale) {
                        // Add random offset to coordinates
                        return vec3(rand( vec2(index)), rand( vec2(index + 1.0)), rand( vec2(index + 2.0))) * scale;
                    }

                    void main() {
                        // Calculate grid position from index
                        float col = mod(a_index, u_gridCols);
                        float row = floor(a_index / u_gridCols);
                        
                        // Map grid to [-1, 1] range
                        vec2 spiralCoord = getSpiralCoordinate(a_index);
                        vec3 noise = getNoise(a_index, 0.05); // Add noise to coordinates
                        spiralCoord += noise.xy; // Add noise to coordinates

                        // Create position vector
                        vec3 pos = vec3(spiralCoord.x, spiralCoord.y, noise.z);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        
                        // Scale point size with screen height for consistent density
                        gl_PointSize = u_pointSize * (u_resolution.y / 900.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;

                    void main() {
                        // Round points with soft edge
                        vec2 p = gl_PointCoord * 2.0 - 1.0;
                        float d = dot(p, p);
                        if (d > 1.0) { discard; }
                        float alpha = smoothstep(1.0, 0.7, 1.0 - d);
                        gl_FragColor = vec4(u_color, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // Create Points object and add to scene
            const points = new THREE.Points(geometry, shaderMaterial);
            scene.add(points);

            // Handle window resize
            // function onWindowResize() {
            //     camera.aspect = window.innerWidth / window.innerHeight;
            //     camera.updateProjectionMatrix();

            //     renderer.setSize(window.innerWidth, window.innerHeight);

            //     // Update resolution uniform
            //     shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            // }

            // window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Update controls for smooth damping
                controls.update();

                // Render the scene
                renderer.render(scene, camera);
            }

            animate();
        }
        setTimeout(() => {
            a();
        }, 3000); // Show error after 5 seconds if Three.js is not loaded
    </script>
</body>

</html>