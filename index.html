<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3GSC - Three.js Points with ShaderMaterial</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #333;
            color: #eaeaf0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            width: 1200px;
            height: 1200px;
            display: block;
            border-radius: 4px;
        }


        a {
            color: #9ab4ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="app">
        <canvas width="1200" height="1200" id="canvas"></canvas>
    </div>

    <script type="importmap">
    			{
    				"imports": {
    					"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
    					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
    				}
    			}
    		</script>



    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 1200;
        function a() {
            const canvas = document.getElementById('canvas');

            // Tweak this to increase/decrease points. Keep reasonable for laptops.
            const NUM_POINTS = 30000;
            const BLACK_HOLE_RADIUS = 0.1;


            // Three.js setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                alpha: false,
                powerPreference: 'high-performance',
            });

            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
            renderer.setClearColor(0x0b0b0f, 1.0);

            // Add post-processing
            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(CANVAS_WIDTH, CANVAS_HEIGHT),
                2.5,    // strength
                1,    // radius
                0.9    // threshold
            );
            composer.addPass(bloomPass);


            // Add OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movements
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5;
            controls.maxDistance = 10;
            camera.position.set(0, -1, .4);


            // Create geometry with only point indices
            const geometry = new THREE.BufferGeometry();
            const indices = new Float32Array(NUM_POINTS); // Only need the index
            const dummyPositions = new Float32Array(NUM_POINTS * 3); // Dummy positions (will be overridden in shader)

            for (let i = 0; i < NUM_POINTS; i++) {
                indices[i] = i;
                // Set dummy positions (these will be ignored in the vertex shader)
                dummyPositions[i * 3] = 0;
                dummyPositions[i * 3 + 1] = 0;
                dummyPositions[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(dummyPositions, 3));
            geometry.setAttribute('a_index', new THREE.BufferAttribute(indices, 1));

            // Custom ShaderMaterial for points
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_color: { value: new THREE.Color(0.92, 0.94, 1.0) },
                    u_pointSize: { value: 2.0 },
                    u_totalPoints: { value: NUM_POINTS },
                    u_time: { value: 0 }, // Add time uniform for potential animations
                    u_blackHoleRadius: { value: BLACK_HOLE_RADIUS }, // Radius of the black hole
                    u_blackHolePosition: { value: new THREE.Vector3(0, 0.0, 0.0) } // Position of the black hole
                },
                vertexShader: `
                    uniform vec2 u_resolution;
                    uniform float u_pointSize;
                    uniform float u_totalPoints;
                    uniform float u_time;
                    attribute float a_index;
                    varying float v_index;
                    varying float vDistanceFromCamera;
                    varying float radius;

                    uniform float u_blackHoleRadius; // Radius of the black hole
                    uniform vec3 u_blackHolePosition; // Position of the black hole

                    float randM1To1(vec2 co){
                        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0; // Center noise around 0
                    }

                    vec3 getNoiseM1To1(float index) {
                        return vec3(randM1To1(vec2(index)), randM1To1(vec2(index + 1.0)), randM1To1(vec2(index + 2.0)));
                    }
                    float getRand01(float index) {
                        return randM1To1(vec2(index,index+5.0)) / 2.0 + 0.5; // Center noise around 0.5
                    }

                    vec3 getSpiralCoordinate(float originalIndex) {
                        v_index = originalIndex;
                        float totalSpirals = 3.0;
                        float totalTurns = 1.0;
                        float pointsPerSpiral = floor(u_totalPoints / totalSpirals);
                        float spiralIndex = floor(originalIndex / pointsPerSpiral);
                        float angleOffset = float(spiralIndex) / totalSpirals * 3.14159 * 2.0;
                        float index = mod(originalIndex, pointsPerSpiral);

                        // Add time
                        float timeOffset = mod(u_time , 1.0);
                        index = mod(index - timeOffset * pointsPerSpiral  ,pointsPerSpiral);

                        // Range from 0 to 1 for the spiral
                        float radiusInSpiral = index / pointsPerSpiral;
                        radius = radiusInSpiral;
                        float angleInSpiral = index / pointsPerSpiral * 3.14159 * 2.0 * totalTurns + angleOffset;

                        // Convert polar to Cartesian coordinates

                        vec3 noise = getNoiseM1To1(originalIndex) * .4;
                        radius *=  (1.0 + noise.x / 2.0);
                        angleInSpiral += noise.y * (10.0) * 3.14159 / 180.0; // Add some noise to the angle
                        float planeAngle = noise.z *  5.0 * 3.14159 / 180.0; // Angle of the spiral plane
                        
            
                        float x = cos(angleInSpiral) * radius;
                        float y = sin(angleInSpiral) * radius;
                        float z = sin(planeAngle) * radius; // Height based on radius
                        // float randomZ = (getRand01(originalIndex) - 0.5) * 0.02;
                        vec3 fullRandom = getNoiseM1To1(originalIndex + 22.2) * .02;
                        return vec3(x + fullRandom.x, y + fullRandom.y, z + fullRandom.z);
                    }

                    vec3 getCoordinateFromBlackHole(vec3 position){
                        vec3 vecFromCenter = position - u_blackHolePosition;
                        float distance = length(vecFromCenter);
                        if( distance > u_blackHoleRadius || distance < 0.001) {
                            return position; // Outside black hole radius, return original position
                        }
                        // scale position towards the black hole
                        float scale = u_blackHoleRadius / distance;
                        return u_blackHolePosition + vecFromCenter * scale;
                    }

                    

                    void main() {
                        vec3 pos = getSpiralCoordinate(a_index);
                        pos = getCoordinateFromBlackHole(pos);
                        vec4 viewPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * viewPosition;
                        vDistanceFromCamera = -viewPosition.z;

                        // Scale point size with screen height for consistent density
                        float pointScale= 4.0 * pow(getRand01(a_index + 7.0)+ 0.1, 3.0) * pow(getRand01(a_index + 9.0)+ 0.1, 3.0);
                        gl_PointSize = u_pointSize * pointScale * (u_resolution.y /1200.0) * (1.0 / vDistanceFromCamera);
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;
                    varying float v_index;
                    varying float vDistanceFromCamera;
                    varying float radius;
                    uniform float u_blackHoleRadius; // Radius of the black hole
                    uniform vec3 u_blackHolePosition; // Position of the black hole
                    vec3 starColors[4] = vec3[4](
                     vec3(0.96, 0.87, 0.70),  // Light golden
                    vec3(0.68, 0.85, 0.90),  // Light blue
                    vec3(0.95, 0.75, 0.95),  // Soft pink/magenta
                    vec3(0.70, 0.95, 0.85)   // Pale cyan/mint

                    );

                    float randM1To1(vec2 co){
                        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
                    }

                    vec3 colorNoise(float index) {
                        index = floor(index);
                        vec3 color = starColors[int(index) % 4];
                        return color;
                    }

                    void main() {
                        // Round points with soft edge
                        vec2 p = gl_PointCoord * 2.0 - 1.0;
                        float d = dot(p, p);
                        if (d > 1.0) { discard; }
                        // float cameraFade = 1.0;
                        float cameraFade = 1.0 - smoothstep(1.0, 5.0, vDistanceFromCamera);
                        float galaxyFade = 1.0;
                        // float galaxyFade = smoothstep(1.0, 0.5, radius);
                        float fade = cameraFade * galaxyFade;
                        // float fade = 1.0;
                        gl_FragColor = vec4(colorNoise(v_index), fade);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // Create Points object and add to scene
            const points = new THREE.Points(geometry, shaderMaterial);
            scene.add(points);
            const blackHoleGeometry = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);

            // Handle window resize
            // function onWindowResize() {
            //     camera.aspect = window.innerWidth / window.innerHeight;
            //     camera.updateProjectionMatrix();

            //     renderer.setSize(window.innerWidth, window.innerHeight);

            //     // Update resolution uniform
            //     shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            // }

            // window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                const time = performance.now() / 10000 / 5; // Get time in seconds
                shaderMaterial.uniforms.u_time.value = time; // Update time uniform

                // Update controls for smooth damping
                controls.update();

                // Render the scene with post-processing
                composer.render();
            }

            animate();
        }
        setTimeout(() => {
            a();
        }, 3000); // Show error after 5 seconds if Three.js is not loaded
    </script>
</body>

</html>