<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3GSC - Three.js Points with ShaderMaterial</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #333;
            color: #eaeaf0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #app {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            width: 1200px;
            height: 1200px;
            display: block;
            border-radius: 4px;
        }


        a {
            color: #9ab4ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="app">
        <canvas width="1200" height="1200" id="canvas"></canvas>
    </div>

    <script type="importmap">
    			{
    				"imports": {
    					"three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
    					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
    				}
    			}
    		</script>



    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 1200;
        function a() {
            const canvas = document.getElementById('canvas');

            // Tweak this to increase/decrease points. Keep reasonable for laptops.
            const NUM_POINTS = 200000;


            // Three.js setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                alpha: false,
                powerPreference: 'high-performance',
            });

            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.setPixelRatio(Math.max(1, Math.min(2, window.devicePixelRatio || 1)));
            renderer.setClearColor(0x0b0b0f, 1.0);


            // Add OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movements
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.5;
            controls.maxDistance = 10;
            camera.position.set(0, -1, .4);

            // Compute grid dimensions for points
            const gridCols = Math.ceil(Math.sqrt(NUM_POINTS));
            const gridRows = Math.ceil(NUM_POINTS / gridCols);

            // Create geometry with only point indices
            const geometry = new THREE.BufferGeometry();
            const indices = new Float32Array(NUM_POINTS); // Only need the index
            const dummyPositions = new Float32Array(NUM_POINTS * 3); // Dummy positions (will be overridden in shader)

            for (let i = 0; i < NUM_POINTS; i++) {
                indices[i] = i;
                // Set dummy positions (these will be ignored in the vertex shader)
                dummyPositions[i * 3] = 0;
                dummyPositions[i * 3 + 1] = 0;
                dummyPositions[i * 3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(dummyPositions, 3));
            geometry.setAttribute('a_index', new THREE.BufferAttribute(indices, 1));

            // Custom ShaderMaterial for points
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_color: { value: new THREE.Color(0.92, 0.94, 1.0) },
                    u_pointSize: { value: 2.0 },
                    u_gridCols: { value: gridCols },
                    u_gridRows: { value: gridRows },
                    u_totalPoints: { value: NUM_POINTS },
                    u_time: { value: 0 }, // Add time uniform for potential animations
                },
                vertexShader: `
                    uniform vec2 u_resolution;
                    uniform float u_pointSize;
                    uniform float u_gridCols;
                    uniform float u_gridRows;
                    uniform float u_totalPoints;
                    uniform float u_time;
                    attribute float a_index;
                    varying float v_index;
                    varying float vDistanceFromCamera;
                    varying float radius;

                    float rand(vec2 co){
                        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453) - 0.5; // Center noise around 0
                    }

                    vec3 getNoise(float index) {
                        return vec3(rand(vec2(index)), rand(vec2(index + 1.0)), rand(vec2(index + 2.0)));
                    }

                    vec3 getSpiralCoordinate(float originalIndex) {
                        float totalSpirals = 5.0;
                        float totalTurns = 2.0;
                        float pointsPerSpiral = floor(u_totalPoints / totalSpirals);
                        float spiralIndex = floor(originalIndex / pointsPerSpiral);
                        float angleOffset = float(spiralIndex) / totalSpirals * 3.14159 * 2.0;
                        float index = mod(originalIndex, pointsPerSpiral);

                        // Add time
                        float timeOffset = mod(u_time , 1.0);
                        index = mod(index - timeOffset * pointsPerSpiral  ,pointsPerSpiral);

                        // Range from 0 to 1 for the spiral
                        float radiusInSpiral = index / pointsPerSpiral;
                        radius = radiusInSpiral;
                        float angleInSpiral = index / pointsPerSpiral * 3.14159 * 2.0 * totalTurns + angleOffset;

                        // Convert polar to Cartesian coordinates
                        float x = cos(angleInSpiral) * radiusInSpiral;
                        float y = sin(angleInSpiral) * radiusInSpiral;
                        vec3 noise = getNoise(originalIndex) * .2 * radiusInSpiral;
                        v_index = originalIndex;
                        return vec3(x + noise.x, y + noise.y, noise.z);
                    }

                    

                    void main() {
                        // Calculate grid position from index
                        float col = mod(a_index, u_gridCols);
                        float row = floor(a_index / u_gridCols);
                        
                        // Map grid to [-1, 1] range
                        vec3 pos = getSpiralCoordinate(a_index);
                        vec4 viewPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * viewPosition;
                        vDistanceFromCamera = -viewPosition.z;

                        // Scale point size with screen height for consistent density
                        gl_PointSize = u_pointSize * (u_resolution.y /1200.0) * (1.0 / vDistanceFromCamera);
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;
                    varying float v_index;
                    varying float vDistanceFromCamera;
                    varying float radius;
                    vec3 starColors[4] = vec3[4](
                        vec3(1.00, 0.63, 0.63),  // red (M type)
                        vec3(0.68, 0.85, 1.00), // light blue (O/B type)
                        // vec3(1.00, 1.00, 1.00), // white (A type)
                        vec3(1.00, 0.96, 0.83), // pale yellow (F/G type)
                        vec3(1.00, 0.83, 0.64) // orange (K type)
                    );

                    float rand(vec2 co){
                        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
                    }

                    vec3 colorNoise(float index) {
                        index = floor(index);
                        vec3 color = starColors[int(index) % 2];
                        return color;
                    }

                    void main() {
                        // Round points with soft edge
                        vec2 p = gl_PointCoord * 2.0 - 1.0;
                        float d = dot(p, p);
                        if (d > 1.0) { discard; }
                        float cameraFade = 1.0 - smoothstep(0.5, 3.0, vDistanceFromCamera);
                        float galaxyFade = smoothstep(1.0, 0.5, radius);
                        float fade = cameraFade * galaxyFade;
                        gl_FragColor = vec4(colorNoise(v_index), fade);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // Create Points object and add to scene
            const points = new THREE.Points(geometry, shaderMaterial);
            scene.add(points);

            // Handle window resize
            // function onWindowResize() {
            //     camera.aspect = window.innerWidth / window.innerHeight;
            //     camera.updateProjectionMatrix();

            //     renderer.setSize(window.innerWidth, window.innerHeight);

            //     // Update resolution uniform
            //     shaderMaterial.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            // }

            // window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                const time = performance.now() / 10000; // Get time in seconds
                shaderMaterial.uniforms.u_time.value = time; // Update time uniform

                // Update controls for smooth damping
                controls.update();

                // Render the scene
                renderer.render(scene, camera);
            }

            animate();
        }
        setTimeout(() => {
            a();
        }, 3000); // Show error after 5 seconds if Three.js is not loaded
    </script>
</body>

</html>